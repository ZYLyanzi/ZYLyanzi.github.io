[{"title":"js核心技巧 笔记整理","date":"2018-08-27T07:24:44.365Z","path":"2018/08/27/js_hexin/","text":"1、在函数前面加 符号，如！，+，~, 等等，表示的是一个函数表达式 (IIFE)如：123!function()&#123;&#125;() 相当于var s = function()&#123;&#125;s() 2、js 有变量提升，但是它是函数级作用域 123456789function test() &#123; var a; if (false)&#123; a = 1 &#125; alert(a); //undefined&#125;test();alert(a) //a is not defined 3、es5里面 块级作用域是怎么实现的 1234567891011121314if(false)&#123; try &#123; throw 1 &#125;catch (a)&#123; alert(a) &#125;&#125;alert(a)相当于if(false)&#123; let a;&#125;alert(a) 4、with 会延长函数的作用域链 12345678910obj.a = 2;obj.b = 3;obj.c = 4;相当于with (obj) &#123; a = 3; b = 4;c = 5;d = 8; &#125; 注意，with只对对象中已有的值进行赋值，如果没有就会创建一个全局变量 5、函数变量提升的优先级要高于变量， 如果变量a没有值，直接被忽略。 1234function a() &#123;&#125; var a; alert(a) //function a() &#123;&#125; a = 1; 12345678(function () &#123; var a = b =1 // 相当于, b是全局变量 // var a = 1; // b = 1;&#125;)()alert(b); //1alert(a);//is not defined 6、es6 是 es5的语法糖 如： class 就是function的原型链实现的 7、es6 里面一定要先定义再使用，如下出现暂时性死区 1234567var i; if (true)&#123; i = 5; let i; &#125; alert(i)// i is not defined","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Css3D应用-陀螺仪","date":"2018-08-14T01:44:42.264Z","path":"2018/08/14/css3D/","text":"一、 陀螺仪角度X（beta,作用域为-180, 180）y（gamma，作用域为-90， 90）z（alpha，作用域为0, 360） 1. deviceorientation 设备的物理方向信息，表示为一系列本地坐标系的旋角。(获取旋转角度)123window.addEventListener(&quot;deviceorientation&quot;, function(event)&#123; // 处理 event.alpha、event.beta、event.gamma&#125;, true); 2. devicemotion 提供设备的加速信息。（获取重力加速度）12345678window.addEventListener(&quot;devicemotion&quot;, function(event)&#123; // 处理event.acceleration // x(y,z): 设备在x(y,z)方向上的移动加速度值 // event.accelerationIncludingGravity // 考虑了重力加速度后设备在x(y,z) // event.rotationRate // alpha, beta, gamma: 设备绕x，y，z轴旋转的角度&#125;, true); 3. compassneedscalibration 用于通知web站点使用罗盘信息校准上述事件。（获取罗盘校准）1234window.addEventListener(&quot;compassneedscalibration&quot;, function(event)&#123; alert(&apos;您的罗盘需要校准&apos;); event.preventDefault();&#125;, true); 简单的摇一摇触发代码123456789101112131415161718192021var speed = 30; // speedvar x = y = z = lastX = lastY = lastZ = 0;function deviceMotionHandler(eventData) &#123; var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; //记录上一次设备在x,y,z方向上的加速度 if ((!lastX) &amp;&amp; (!lastY) &amp;&amp; (!lastZ)) &#123; lastX = acceleration.x; lastY = acceleration.y; lastZ = acceleration.z; return; &#125; if (Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed )&#123; // 简单摇一摇触发代码 alert(1); &#125;&#125; 二、 Touch事件最基本的touch事件包括4个事件：touchstart: 当在屏幕上按下手指时触发touchmove: 当在屏幕上移动手指时触发touchend: 当在屏幕上抬起手指时触发touchcancel:当一些更高级别的事件发生的时候（如电话接入或者弹出信息）会取消当前的touch操作，即触发touchcancel。一般会在touchcancel时暂停游戏、存档等操作。 三、 Css核心技巧 1、 布局方式圣杯布局，双飞翼布局，绝对定位布局，flex布局（圣杯，双飞翼为了兼容早期的ie浏览器，兼容性最好） 2、 引用neat.css 处理一些兼容性问题 3、 Cssicon 图标 四、 css3D转换 transform 上面的translateZ, 当translateZ为正值的时候，元素会向其面对的方向走去；如果元素无旋转，就会朝显示器走来！！r = 64 / Math.tan(20 / 180 * Math.PI) ≈ 175.8","tags":[{"name":"cssl","slug":"cssl","permalink":"http://yoursite.com/tags/cssl/"}]},{"title":"跨域 和 html语义化笔记整理","date":"2018-08-02T12:12:11.497Z","path":"2018/08/02/origin/","text":"一、 关于前端跨域1）、同源：端口，域名，协议2）、同源的目的：保证用户信息安全，防止恶意的网站窃取数据。3）、浏览器不同域名不能访问对应的cookie，但内部表单不受限制，所以会造成跨站攻击。4）、同源策略限制的对象：Cookie，LocalStrorage 和IndexDB 无法读取。DOM无法获得。Ajax请求不能发送。5）、突破同源策略1.document.domain = ‘*.com’ //设置同域， 此方案仅限主域相同，子域不同的跨域应用场景。2．Jsonp的原理， 二、 关于 WebSQl，IndexedDB三、 关于 QPS测试手机网速webapp页面，根据这个网速，可以给用户出一些网速比较慢的解决方案。比如跳转到简版的网页。测试的代码：12345678910var s = new Image();var start = Date.now();s.src = &apos;http://cdn-img.17weima.com/2018newyear/lottery/bitmap.png&apos;; //例子 ...s.png = 3.33.5kbs.onload = function (argument)&#123; var end = Date.now(); t = end-start; v = (Math.round (3.33*1000)/t)+ &apos;kb/s&apos;; console.log(v)&#125;s.onload() 三、 关于 html 语义化使用div进行布局，不要用div进行无意义的包裹，尽可能少使用无语义的标签div和span尽量少写html。少写html可以减少dom的渲染时间，还可以避免浪费整个文件的大小。","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"关于 this","date":"2018-08-01T12:44:12.770Z","path":"2018/08/01/es5_this/","text":"1、this最终指向的是调用它的对象 2、这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 3、如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 1234567891011121314151617181920212223242526272829303132333435//示例一function a()&#123; var user = &quot;yanzi&quot;; console.log(this.user) //undefined console.log(this) //Window&#125;window.a();//示例二var o = &#123; a: 10, b: &#123; a: 12, fn: function()&#123; console.log(this.a) // 12 &#125; &#125;&#125; o.b.fn(); //示例三 function fn()&#123; this.user = &quot;yanzi&quot;; return function()&#123;&#125;; &#125; var a = new fn; console.log(a.user); //undefined //示例四 function fn()&#123; this.user = &quot;yanzi&quot;; return 1; &#125; var a = new fn; console.log(a.user); //yanzi","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"CSS3基础笔记整理（一）","date":"2018-07-09T08:27:28.399Z","path":"2018/07/09/about_css3/","text":"一、边框 1、圆角 border-radius： 2、阴影 box-shadow：box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]; X轴偏移量：必填，水平阴影位置，允许负值。Y轴偏移量：必填，垂直阴影位置，允许负值。阴影模糊半径：可选， 模糊距离， 只能是正值。阴影扩展半径：可选， 扩展尺寸。阴影颜色：可选，省略默认黑色。投影方式：可选，设置 inset时为内部阴影，省略为外部阴影。 3、边框应用图片 border-image： 二、颜色 1、RGBA：RGB是一种色彩标准，是由红(R)、绿(G)、蓝(B)的变化以及相互叠加来得到各式各样的颜色。RGBA是在RGB的基础上增加了控制alpha透明度的参数。1background-color:rgba(100,120,60,0.5); 2、 渐变：CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。linear-gradient(渐变方向, 颜色起始点和结束点、可以有两个至多个色值…)1background-image:linear-gradient(to left, red, orange,yellow,green,blue,indigo,violet); 三、文字 1、text-overflow 与 word-wrap： text-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出。word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。12text-overflow：clip（剪切）| ellipsis （省略标记）word-wrap：normal (控制连续文本换行) | break-world （边界内换行） 2、嵌入字体@font-face： 3、文本阴影text-shadow 四、背景 1、background-origin 设置元素背景图片的原始起始位置。参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。1background-origin ： border-box | padding-box | content-box; 2、background-clip 用来将背景图片做适当的裁剪以适应实际需要。参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。1background-clip ： border-box | padding-box | content-box | no-clip 3、background-size 设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。1background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain 4、多重背景","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"CSS3基础笔记整理（二）","date":"2018-07-09T05:44:11.086Z","path":"2018/07/09/about_css3_2/","text":"五、选择器1、属性选择器：123456789101112a[class^=icon]&#123; background: green; color:#fff;&#125;a[href$=pdf]&#123; background: orange; color: #fff;&#125;a[title*=more]&#123; background: blue; color: #fff;&#125; 2、 结构性伪类选择器—root：:root选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是&lt;html&gt;。 3、结构性伪类选择器—not：:not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。 4、结构性伪类选择器—empty：:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。 5、结构性伪类选择器—first-child：:first-child选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。 6、结构性伪类选择器—last-child：:last-child选择器与:first-child选择器作用类似，不同的是:last-child选择器选择的是元素的最后一个子元素。 7、结构性伪类选择器—nth-child(n)：:nth-child(n)选择器用来定位某个父元素的一个或多个特定的子元素。其中n是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。 8、结构性伪类选择器—nth-last-child(n) 9、first-of-type选择器 :first-of-type选择器类似于:first-child选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。 10、 nth-of-type(n)选择器 :nth-of-type(n)选择器和:nth-child(n)选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。 11、 last-of-type选择器 :last-of-type选择器和:first-of-type选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。 12、nth-last-of-type(n)选择器 13、only-child选择器 :only-child选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。 14、 only-of-type选择器 15、 :enabled选择器 在Web的表单中，有些表单元素有可用:enabled和不可用:disabled状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器:enabled对这些表单元素设置样式。 16、 :disabled选择器 :disabled选择器刚好与:enabled选择器相反，用来选择不可用表单元素。 17、 :checked选择器 在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。而:checked表示的是选中状态。 18、 ::selection选择器 19、 :read-only选择器 :read-only伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了readonly=’readonly’。 20、:read-write选择器 :read-write选择器刚好与:read-only选择器相反，主要用来指定当元素处于非只读状态时的样式。 22、 ::before和::after ::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常和content配合使用，使用的场景最多的就是清除浮动。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"关于消除img间的间隙问题","date":"2018-03-15T08:51:47.363Z","path":"2018/03/15/css_img/","text":"img标签为什么会有上下间隙呢？原因在于：img标签为inline元素，该元素默认垂直对齐方式为以父元素的baseline，但是展示时又是以bottomline为对齐方式，因此造成了上下两个img标签之间的间隙。有以下四种方案可以解决： 1、img{ display:block}; 将其改变为block元素，但是该方法太过粗暴，相当于从根本上改变了img。2、img{vertical-align:top;} 改变其垂直对齐方式3、div{font-size:0}; 把父元素的文字大小设置为04、div{ margin-bottom:-3px }; 这个方法不推荐","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"js Date对象在Safari与IOS中的兼容性问题","date":"2018-03-15T08:39:10.643Z","path":"2018/03/15/js_ios/","text":"最近写个移动端的项目，发现在Android和pc浏览器上都可以运行，但是在ios和Safari上效果没有呈现，最后找到原因是，“Safari与IOS对Date对象的兼容性问题”。 看下面代码：1var date =new Date(&quot;2017-12-27 08:00&quot;); 这段代码是获取字符中的指定日期，但是在Safari上就会报错。不过像下面这样写就不会报错：1var date =new Date(&quot;2017/12/27 08:00&quot;); 一般我们的日期格式都是这种“2017-12-27 08:00”，所以我们需要写个函数，替换一下，这样Android和IOS就能共用了呀！1234getDateDiff(time) &#123; //将xxxx-xx-xx的时间格式，转换为 xxxx/xx/xx的格式 return time.replace(/\\-/g, &quot;/&quot;);&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"git commit 和切换分支","date":"2018-02-26T01:52:14.165Z","path":"2018/02/26/git_commit/","text":"git 切换分支的时候是否需求提交当前已经修改的内容？ 当你当前分支又修改的情况下，切换分支，有三种方式： 1、先提交修改到当前分支，再切换 git add . git commit git checkout 分支名 2、不提交当前修改，先把修改暂存，再切换 git add . git stash git checkout 分支名 当再次checkout回来之后，再提交当前分子 git stash apply git commit 3、 不提交当前修改，直接切换分支，，注意，这样的话会把当前修改记录到切换当分支下面 git add . git commit git checkout 分支名","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"开发微信小程序中所遇到的问题","date":"2017-11-09T07:53:24.025Z","path":"2017/11/09/wxxq/","text":"一、页面栈的控制官方规定小程序最多只能有 五个页面 同时存在，意思是在不关闭页面的情况，最多新开五个页面，页面深度为5。 但是目前一般来说，应用的业务场景和交互逻辑，远远不止5个页面栈。那如何用 五个页面 去实现更多复杂的流程呢？我们将从以下3个方面去进一步了解: 小程序的4种导航跳转方式 选择页面的跳转方式的选择 页面传参 1、小程序的4种导航跳转方式wx.navigateTo：保留当前页面，跳转到新的页面，此时页面栈会加一个页面信息，此时页面栈数加一。 wx.redirectTo：关闭当前页面，跳转到指定页面，这里的关闭在页面栈里面是删除对应的页面信息，此时页面栈数减一。 wx.navigateBack：关闭当前页面，返回上一页面或多级页面。此时页面栈数减一。如果要跳转到指定页面，可以通过getCurrentPages()方法获取页面栈的长度，可以根据这个数跳转到指定页面。 wx.switchTab：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，这个是新出来的API,在我开发过程中没有提供此方法，不过用此方法跳转还是又一定限制，如果用页面栈里面将重新洗牌了。 2、选择页面的跳转方式的选择 对于可逆操作使用 wx.navigateTo，比如一级页面跳二级页面。每新开一个页面，页面栈大小加一 对于不可逆操作使用 wx.redirectTo，比如登录页，登录成功后关闭登录页。 对于列表，还有介绍性等不常用的页面使用 wx.navigatrBack 3、页面传参小程序页面之间的数据传输，放在Storage缓存里面，让每一个页面都能共享到相同数据。 比如：A页面和B页面，点击A页面的按钮进入B页面，然后在B页面选择日期后返回A页面，A页面要显示B页面选择的日期。 我们可以使用 wx.navigateTo + wx.navigateBack + onShow方式 来实现（A页面 wx.navigateTo B页面。B页面 wx.navigateBack A页面，把日期setStorage到缓存里。然后在A页面的 onShow 方法里 重新加载数据） 二、事件对象要注意 target 和 currentTarget 的使用。target 触发事件的源组件。currentTarget 事件绑定的当前组件。","tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"开发微信小程序","date":"2017-11-09T07:53:24.017Z","path":"2017/11/09/wxxiaochengxu/","text":"整体配置 1、必不可少的三个文件app.js、app.json、app.wxss，js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件 2、 app.js是小程序的脚本代码，在这个文件中监听并处理小程序的生命周期函数、声明全局变量，调用API 3、app.json是对整个小程序的全局配置，在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题 4、​ app.wxss是整个小程序的公共样式表 创建页面 每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。 1、规定描述页面的这四个文件必须具有相同的路径与文件名 2、页面的配置文件（.json），或者样式文件（.wxss）， 会覆盖 app.json、app.wxss 关于页面组件和样式 1、小程序里是没有div的，要用view2、小程序没有a标签，页面链接用 navigator3、样式的话，抛开盒模型，用flex写布局。 关于列表渲染和操作WXML 中的动态数据均来自对应 Page 的 data。xxx.js12345678910111213141516171819202122232425262728Page(&#123; data:&#123; manager_list:[ &#123; user_id: 1, user_name: &quot;小红花&quot;, mobile: &quot;18612345678&quot; &#125;, &#123; user_id: 2, user_name: &quot;小胖子&quot;, mobile: &quot;18612345678&quot; &#125;, &#123; user_id: 3, user_name: &quot;烟仔&quot;, mobile: &quot;18612345678&quot; &#125;, &#123; user_id: 4, user_name: &quot;对的&quot;, mobile: &quot;18612345678&quot; &#125;, &#123; user_id: 5, user_name: &quot;飒飒&quot;, mobile: &quot;18612345678&quot; &#125; ] &#125;, 使用wx:for 渲染列表。使用 wx:for-item 可以指定数组当前元素的变量名。使用 wx:for-index 可以指定数组当前下标的变量名.xxx.wxml 12345&lt;view class=&quot;items&quot; wx:for = &quot;&#123;&#123;manager_list&#125;&#125;&quot; wx:key=&quot;unique&quot; wx:for-item = &quot;item&quot; wx:for-index = &quot;idx&quot;&gt; &lt;view class=&quot;top&quot;&gt; &lt;text class=&quot;user-name&quot;&gt;&#123;&#123;item.user_name&#125;&#125;&lt;/text&gt; &lt;view class=&quot;del&quot; bindtap = &quot;delete_admin&quot; data-idx = &quot;&#123;&#123;idx&#125;&#125;&quot;&gt;删除&lt;/view&gt;&lt;/view&gt; bindtap = “delete_admin” 双击事件绑定 delete_admin（）方法。小程序里面是不能用js操作dom的，所以，如果我们要实现，点击 删除 按钮，获取该用户id，可以 用wx:for-index，把前数组的下标存起来。 在xxx.js 中，可以这么获取：1var i = e.target.dataset.idx; 表单提交 表单组件中 name 来作为 key,当点击 表单中 formType 为 submit 的 button 组件时，会将表单组件中的 value 值进行提交。 xxx.wxml12345678910111213141516&lt;form bindsubmit=&quot;formSubmit&quot;&gt; &lt;view class=&quot;top&quot;&gt; &lt;view class=&quot;name&quot;&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;input name=&quot;user_name&quot; placeholder=&quot;请输入管理员姓名&quot; maxlength = &quot;15&quot; value = &quot;&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;tel&quot;&gt; &lt;label&gt;手机号码&lt;/label&gt; &lt;input name=&quot;mobile&quot; placeholder=&quot;请输入管理员手机号&quot; type=&quot;number&quot; maxlength = &quot;11&quot; value=&quot;&quot;/&gt; &lt;/view&gt; &lt;text class=&quot;dec&quot;&gt;管理员可用手机号码登录&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;bottom&quot;&gt; &lt;button formType=&quot;submit&quot;&gt; 完成 &lt;/button&gt; &lt;/view&gt;&lt;/form&gt; xxx.js 12345678910111213141516171819202122232425262728293031323334353637383940formSubmit: function(e) &#123; if(e.detail.value.user_name.length==0)&#123; wx.showToast(&#123; title: &apos;姓名不能为空!&apos;, icon: &apos;loading&apos;, duration: 700 &#125;) &#125;else if(e.detail.value.mobile.length===0)&#123; wx.showToast(&#123; title: &apos;手机号码不能为空!&apos;, icon: &apos;loading&apos;, duration: 700 &#125;) &#125;else if(!(/^1(3|4|5|7|8)\\d&#123;9&#125;$/.test(e.detail.value.mobile)))&#123; wx.showToast(&#123; title: &apos;请输入正确的手机号码!&apos;, icon: &apos;loading&apos;, duration: 700 &#125;) &#125;else&#123; wx.request(&#123; url: &apos;https://xxx&apos;, data:&#123; mobile: e.detail.value.mobile, user_name: e.detail.value.user_name &#125;, method: POST, header: &#123; &apos;content-type&apos;: &apos;application/json&apos;, &#125;, success: function(res) &#123; if(res.err_code == 0)&#123; wx.redirectTo(&#123; url: &apos;/pages/admin/manag_admin/manag_admin&apos; &#125;) &#125; &#125; &#125;) &#125; &#125;,","tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"前端资源推荐","date":"2017-11-09T07:53:24.013Z","path":"2017/11/09/websource/","text":"最全的资源教程-前端涉及的所有知识体系 https://github.com/AutumnsWind/Front-end-tutorial 前端导航 http://whycss.com/ 开发者头条 http://toutiao.io/ git中文帮助文档 https://git-scm.com/book/zh/v1/ 在线JSON校验 http://www.bejson.com/ 阮一峰ECMAScript 6中文教程 http://es6.ruanyifeng.com/ React Native中文网 http://reactnative.cn/ 腾讯AlloyTeam全端团队Blog http://www.alloyteam.com/ 百度前端研发部Blog http://fex.baidu.com/ 淘宝网UED团队Blog http://ued.taobao.org/blog/ 阿里巴巴国际UED团队Blog http://www.aliued.com/ php大牛惠新宸Blog http://www.laruence.com/ 浏览器兼容插叙 [http://caniuse.com/] 设计模式书籍：《Head First 设计模式》","tags":[]},{"title":"前端性能优化总结","date":"2017-11-09T07:53:24.005Z","path":"2017/11/09/webperformance/","text":"我们建立网站就是想让目标人群来访问，前端是用户所直接接触的。为了给用户更好的体验，前端性能优化是必须滴！最近读了本《高性能的JavaScript》，然后结合实际遇到的问题。总结以下几个方面进行前端性能优化： 一、 加载 &lt;body&gt;标签闭合之前，将js放在底部，将css放在顶部 这样能保证在脚本执行之前页面已经完成渲染，避免加载js对后续的资源造成阻塞。 二、 数据 1. 能使用局部变量。和字面量（int a=1）的，尽量不使用全局变量 因为局部变量存在作用域链的 起始位置 ，因此访问局部变量比访问跨作用域链的变量更快。变量在作用域链的位置越深，访问时间越长，而全局变量处在作用域链的 最末端 ，因此访问速度最慢。 2. 嵌套对象成员会影响性能，尽量少用嵌套越深，读取越慢，每次的点操作符，js引擎都会搜索所有的对象成员。所以location.href优于window.location.href 3.缓存对象成员值 把常用的对象成员，数组元素，跨域变量保存在局部变量中，前面也说了局部变量的访问速度是最快的捏！12345678910function toggle(element)&#123;YAHOO.util.Dom.hassClass(element,”selected”)YAHOO.util.Dom.removeClass(element,”selected”)&#125;改良后↓function toggle(element)&#123;var Dom = YAHOO.util.DomDom.hassClass(element,”selected”)Dom.removeClass(element,”selected”)&#125; 三、 DOM编程 1. 最小化DOM访问次数 因为DOM访问次数越多，DOM重绘重排就越多，如果要多次改动DOM结构，就应该把要改动的部分先取出来，改动完成后再放回去。12345678910111213var top_100_list = [...], // 这里是100个字符串的数组 $mylist = $(&quot;#mylist&quot;); for (var i=0, l=top_100_list.length; i&lt;l; i++)&#123; $mylist.append(&quot;&lt;li&gt;&quot; + top_100_list[i] + &quot;&lt;/li&gt;&quot;); // 100次DOM操作&#125;改良后↓var top_100_list = [...],$mylist = $(&quot;#mylist&quot;),top_100_li = &quot;&quot;; // 这个变量用来存储变化的字符串for (var i=0, l=top_100_list.length; i&lt;l; i++)&#123; top_100_li += &quot;&lt;li&gt;&quot; + top_100_list[i] + &quot;&lt;/li&gt;&quot;;&#125; $mylist.html(top_100_li);// DOM操作只有这么一次 2.使用局部变量存储DOM节点的引用 如果需要多次访问某个DOM节点，使用局部变量存储它的引用12345678var sub_order_id =$(checkbox[i]).closest(&quot;tr&quot;).find(&quot;input[class=&apos;sub_order_id&apos;]&quot;).val();var ticket_id = $(checkbox[i]).closest(&quot;tr&quot;).find(&quot;input[class=&apos;ticket_id&apos;]&quot;).val();var price = $(checkbox[i]).closest(&quot;tr&quot;).find(&quot;input[class=&apos;ticket_price&apos;]&quot;).val();改良后↓var tr = $(checkbox[i]).closest(&quot;tr&quot;);var sub_order_id = tr.find(&quot;input[class=&apos;sub_order_id&apos;]&quot;).val();var ticket_id = tr.find(&quot;input[class=&apos;ticket_id&apos;]&quot;).val();var price = tr.find(&quot;input[class=&apos;ticket_price&apos;]&quot;).val(); ３.把集合的长度缓存到变量中,并在迭代中使用它123for(var i = 0,len = array.length; i &lt; len; i++ )&#123; //alert(i);&#125; 4.使用事件委托减少事件处理器的数量 那什么是事件委托，可参考我的其中一篇博文，js事件委托 四、 算法和控制流程 1. 避免使用 for-in 循环 数组一定不要 用 for-in 循环，除非遍历个属性数量未知的对象 2. 避免使用多重循环 改善性能最佳方式就是减少每次迭代的运算量和减少循环迭代的次数 3. 正确使用 switch和if-else 通常来说，switch是比if-else更快，但是在条件数量很大时才明显，所以通常，条件数量少的时候使用 if-else 五、 实践中 1. 尽量使用直接量创建对象和数组直接量的创建和初始化都比非直接量形式要快12345678910var arr = new Object();arr.name = “yanzi”arr.age= 20arr.sex = “girl”改良后↓var arr = &#123;name :”yanzi”,age:20,sex:”girl”&#125;; 2. 考虑使用位运算 进行数学计算 但是位运算感觉容易出错，而且比较复杂，所以我基本不用，嘿嘿。。。 3. 尽量使用javascript的原生方法 六、 构建和部署（最重要的方面） 1. 减少http请求次数 网站提速最重要的一条规则就是减如少页面渲染所需的http请求数。每次http请求都需要建立通信链路、进行数据传输，而在服务器端，每个http都需要启动独立的线程去处理。 2. 合并压缩 减少http请求次数，合并多个图片，js和css文件。比如加载一个页面，果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。合并css图片，使用Sprites。Javascript压缩，可以把文件中与运行无关的部分进行剥离，比如包括注释和不必要的空白字符。这样的过程通常可以将文件大小减半，使文件更快的被下载，缩小请求返回的数据量。 3. 使用构建工具，比如gulp 在构建时能完成的工作就不要留到 运行中，像合并，压缩，预处理这些步骤最好都是在构建时先完成。 4. 避免空的src和href 当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。 5. 避免使用CSS表达式和内联的CSS样式 将CSS和JS放到外部文件中，目的是缓存文件。 但有时候为了减少请求，也会直接写到页面里，这个需根据PV和IP的比例权衡。 6. 图片使用延时加载 我现在的做法是，将图片的src用占位符图片代替，并使用data-src属性保存真实的图片地址，然后监控window的scroll事件，当图片出现在屏幕中时，就将data-src的值赋值给src。 7. 设置缓存 当用户在浏览器的地址栏中敲入了网站的网址 ( 比如 google.com ) ,浏览器首先会通过访问的域名来定位到IP (DNS) 从而找到去哪里获取资源, 这时, 浏览器会依次进行如下查找： 浏览器缓存 系统缓存 路由器缓存 ISP DNS缓存 递归搜索…所以对一个网站而言，设置缓存是必要的。特别是像CSS、javascript、logo、图标这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次http请求都需要的，如果将这些文件缓存在浏览器中，它可以极好的改善性能。设置缓存的原创很简单，能缓存越多越好，能缓存越久越好。通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以是数天，甚至是几个月。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。 为文件头指定ExpiresExipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。 配置ETags响应头部中会包含一个ETag的信息，它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。浏览器请求具体过程可看下图： 值得注意的是： 适当的缓存可以提升用户体验，但是有个缺点，当应用升级时，我们要把用户缓存的静态资源更新。这个可以通过静态资源重命名解决，一般我们是给文件增加一个版本号或者开发编号。还有就是不宜一次更新全部文件，应该一个个逐步更新，忽然大量缓存失效，会使服务器负载骤增，网络堵塞的 8. 权衡DNS查找次数 我们来分析一下浏览器与服务器之间一次典型的通信过程. DNS 查询 TCP 连接 HTTP 请求与响应所以减少主机名会节省响应时间，但是同时也会减少并行的下载数量，IE浏览器同一时刻只能从同一域名下载两个文件，所以会影响下载速度。所以我们可以用多个域名来存放图片，例如可以看下新浪微博的图片存放。你会发现有的图片的地址是 http://tva2.sinaimg.cn/， 有的图片则是 http://ww2.sinaimg.cn/ 9. 使用内容分发网络（CDN） CDN（contentdistribute network，内容分发网络）的本质仍然是一个缓存，而且 将数据缓存在离用户最近的地方 ，使用户以最快速度获取数据。CDN缓存的一般是静态资源，如图片、文件、CSS、script脚本、静态网页等，但是这些文件访问频度很高，将其缓存在CDN可极大改善网页的打开速度。 10. 使用GET来完成AJAX请求 当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。当数据量小的时候使用 GET ，超过2048个字节的时候用POST。因为ie限制URL长度，过长会导致URL被截断 11. 避免使用 eval和 Function 构造函数 会导致双重求值得性能消耗","tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"}]},{"title":"标准W3C盒子模型和IE(IE6及其以前)盒子模型","date":"2017-11-09T07:53:24.001Z","path":"2017/11/09/w3c_box/","text":"盒模型：content，padding。border，margin W3C盒子模型和IE(IE6及其以前)盒子模型的区别是，IEcontent部分包含了padding和border。 比如：一个盒子，content的宽为100px，高为50px；padding是10px；border是2px；margin是20px；W3C盒子模型解释盒子占据的位置为：宽 100+102+22+202=164 高 50+102+22+202=114W3C盒子模型解释盒子实际大小为：宽 100+102+22=124 高 50+102+22 = 74IE盒子模型解释盒占据的位置为：宽 100+202= 140 高 50+202= 90IE盒子模型解释盒实际大小为：宽 100 高 50 那么应该选择哪种盒子模型呢？当然是标准W3C盒子模型啦！所以加上doctype声明，所有浏览器都会采用标准W3C盒子模型，网页就能在各个浏览器中显示一致了。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"一个简单的 Vue实践 项目","date":"2017-11-09T07:53:23.996Z","path":"2017/11/09/vue_project/","text":"本文的主要内容如下： 安装插件 组件的结构 组件的应用 路由的应用 用mock.js模拟数据 编译 如果还没有搭建Vue的项目环境，请参考vue-cli构建vue项目关于Vue是什么，以及它的基本语法，请参考Vue.js的官方文档介绍。 图解MVVM（Model-View-ViewModel）模式的Vue： 现在开始Vue实践之旅啦1.首先，先来安装几个插件（后面会说用来干嘛的）npm install vue-router –savenpm install vue-resource –savenpm install mockjs –save( –save 可以让该插件显示在 package.json 的dependencies中) 2.打开工程目录下的App.vuetemplate 写 html，script写 js，style写样式 3.组件的应用组件系统是Vue的重要概念，我们可以用小的组件来构建大型的应用，任意个应用界面我们都可以抽象成一个组件树。在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例。 创建个组件：在工程/src/component文件夹下，创建个First.vue文件，并仿照App.vue的格式 写第一个组件 然后在 App.vue 使用组件 ( 因为在 index.html 里面定义了&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;所以就以这个组件作为主入口，方便 ) 第一步，引入。在&lt;script&gt;&lt;/script&gt;标签内写：1import First from &apos;./components/First&apos; 第二步，注册。在&lt;script&gt;&lt;/script&gt;标签内的 components 加上 引入的组件 First 记得中间加英文逗号!!! 第三步，使用。在&lt;template&gt;&lt;/template&gt;内加上 &lt;first&gt;&lt;/first&gt;这时你会看到浏览器的页面效果显示如下： 4.路由的应用前面已经装好了vue-router，使用 vue-router 搭建单页应用，主要有五步： 创建组件 创建路由 创建和挂载实例 渲染匹配的组件 &lt;router-link&gt;组件跳转到指定路径 页面呈现，噢啦 第一步，创建组件 在 src 下新建文件夹 views ，在该文件夹下新建两个文件 PageOne.vue ,PageTwo.vue为了方便 PageOne.vue 我们直接复制 为了方便 App.vue 的代码，PageTwo.vue 复制 First.vue 的代码 第二步，创建路由 在 src 下新建文件夹 js ，在该文件夹下新建 vue-router.js 文件在这里创建路由（粘贴的代码图中都有注释，我就不一一解释了哈！！！！） 第三步，创建和挂载实例 修改 main.js 第四步，在页面上使用&lt;router-view&gt;&lt;/router-view&gt;标签，渲染匹配的组件。修改 App.vue 第五步：使用&lt;router-link&gt;组件跳转到指定路径 注意！！！在Vue 2中，v-link指令已经被一个新的&lt;router-link&gt; 组件指令替代 最后你会看到下面的效果，点击 下面的 who are you ？ 跳转到 http://localhost:8080/PageTwo： 5.用mock.js模拟数据 新建Mock.js文件 在 src/js 新建 Mock.js 文件内容如下：Mock.mock 是 Mock的方法，第一个参数自定义的url（也就是接口），后面的参数可自定义配置。具体配置参数编写，可参考Mock.js. 引入Mock.s 和 vue-resource在 main.js 引入 输出数据 我们在 First.vue 上来动态加载数据 duang，duang，duang!!!!现在可以看到页面上有数据啦： 6.编译npm run build","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"vue-cli构建vue项目","date":"2017-11-09T07:53:23.992Z","path":"2017/11/09/vue/","text":"环境搭建 1. 安装node.js 2.安装vue-cli npm install -g vue-cli 3.使用vue-cli初始化项目 vue init webpack vue-test 设置介绍Project name 项目名称project des 项目描述Autor 项目作者 一般推荐下面项直接选择 No，嘻嘻！！新手入门，先别整那么复杂eslint是个代码规范检查工具 4.进到目录 cd vue-test(yours-project-name) 5.安装依赖 npm install 6.开始运行 npm run dev浏览器会直接打开你的项目，你会进到一个hello world的起始页！到这里为止，你得环境就已经搭好了，， Vue项目实践请参考一个简单的 Vue实践 项目","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"整理几点编辑静态页面的 整体思路和技巧","date":"2017-11-09T07:53:23.987Z","path":"2017/11/09/static_html/","text":"1、 先写大体框架，分区域 2、 Ps，F2选取图层当前大小 3、 切图，转化为智能对象，双击 4、 背景透明，有阴影过渡效果的用png，不能用gif 5、 单色，要求不高，用gif，比较小 6、 按住ctr键，单击图层图标，然后出现该图层选区 7、 选择-》载入选区-》新建，ctrl+shift+c（选区与实际大小不相符的时候） 8、 色彩丰富用jpg","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"phpstorm 7.0结合 file watchers sass/scss自动编译","date":"2017-11-09T07:53:23.983Z","path":"2017/11/09/php_sass02/","text":"1.ctrl+alt+s，调出settings，搜索 File Watchers，添加SCSS 2.设置可以看下图，要注意的是 [Program] 最好指定具体目录,用环境变量 $RUBY_HOME$\\scss.bat,会出错 3.Arguments 就是写上sass/scss支持的 语法 例如 –style compressed test.sass test.css, 上图的配置是scss源目录+css生成目录，如下： –style expanded $FileDir$\\$FileName$ $FileParentDir$\\css\\$FileNameWithoutExtension$.css","tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"phpstorm安装 SASS、SCSS + Compass","date":"2017-11-09T07:53:23.978Z","path":"2017/11/09/php_sass/","text":"1. 安装 PHPStorm 的 SASS 插件好像是自带了该插件的，如果没有的话，就打开 setting -&gt; plugins 自己安装一个吧，就不多说了 2. 安装 RubyWindows 版本下载地址：http://rubyinstaller.org/downloads/Linux or Mac 地址：http://ruby.taobao.org/mirrors/ruby/我用的是 windows 版最新的 2.2.1 版本配置好系统环境，将ruby 的bin目录绝对路径添加到 path 环境变量中，windows版安装的时候可以勾选自动添加可参考这片博文：http://www.w3cplus.com/css/css-preprocessor-sass-vs-less-stylus-2.html 3. 安装 SASS 和 Compass你可能需要重新设置下更新源地址：命令行下执行：[plain] view plain copy 在CODE上查看代码片派生到我的代码片gem sources –remove https://rubygems.org/gem sources -a https://ruby.taobao.org/（这里不能 https://ruby.taobao.org/ 源可能用不了了，可以用 http://gems.ruby-china.org） 可以参考下这篇文章：http://devework.com/sass-compass.html下面执行安装啦：[plain] view plain copy 在CODE上查看代码片派生到我的代码片gem install sassgem install compass 4. 新建 Compass + SASS 项目创建一个项目根目录，cd 进入后，执行：compass create your_project_name会生成三个文件夹和一个 config.rb 文件在 sass 目录下存放我们自己的样式代码，编译后会自动生成到 stylesheets 目录下，当然你也可以自定义生成地址 5. 配置 Compass 编译环境打开 setting -&gt; Language &amp; Framework 下面有个 Compass勾选 Enable 后 设置你自己安装的 ruby comopass.bat 路径 和 当前项目的 config.rb 文件路径 6. 配置 SASS 环境打开 setting -&gt; Tools -&gt; FileWatchers点击右侧绿色的加号 添加一个 compass scss 项目，配置如下 应该使用默认的配置就可以的了。working directory 就是你 刚才用 compass create 的项目目录（我这里只是文件夹名字是 less 不要误解了啊） 7. 开始写代码了12345678910111213141516171819202122232425262728@import &quot;compass/reset&quot;; @import &quot;compass&quot;; $fc: #FFF; $fs: 16px; body &#123; background-color: #555; &#125; #panel &#123; color: $fc; font-size: $fs; .title &#123; padding: 1em; background-color: #888; color: $fc; &#125; .item &#123; float: left; width: 49%; min-height: 3em; padding: 1em; margin: 1.5%; border: solid 1px $fc; box-sizing: border-box; background-color: #999; @include box-shadow(1px 2px 3px #000); &#125; &#125; 一个简单的测试代码，每次更改后，会自动编译，但不会自动生成 css 文件的，你可以在命令行下进行生成命令如下：compass compile或者强制编译更新:compass compile –force 然后你再看看 stylesheets 下面就多出一个对应名称的 css 文件这个代码会有很大一堆我就不上代码了，包含了 reset 的样式和你自己的样式 还有注释都保留了的，因为这是开发环境，如果是正式环境，需要进行压缩下面来改下配置，进入正式环境，将生成的代码压缩成一行打开项目根目录下的 config.rb 文件添加两行代码：environment = :developmentoutput_style = (environment == :production) ? :compressed : :expanded 当 environment 为 :production 时生成的 css 文件将会是压缩成一行的样子了。 好了 全部完成，现在开始快速开发你自己的 css 吧如果你只需要用 SCSS 的话，在第6步你可以新建 SCSS 配置，下面是配置截图","tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"phpstorm配置Xdebug进行调试","date":"2017-11-09T07:53:23.973Z","path":"2017/11/09/php_debug/","text":"1、下载xdebug文件http://xdebug.org/download.php（注：如果开发环境里装了xampp，其集成了php的开发平台，可以不用下载，省略这步） 2、配置php.ini，在末尾加上123456789101112zend_extension = &quot;D:\\xampp\\php\\ext\\php_xdebug.dll&quot;//xdebug文件的所在路径xdebug.profiler_append = 0xdebug.profiler_enable = 1xdebug.profiler_enable_trigger = 0xdebug.profiler_output_name = &quot;cachegrind.out.%t-%s&quot;xdebug.remote_handler = &quot;dbgp&quot;xdebug.remote_host = &quot;127.0.0.1&quot;xdebug.trace_output_dir = &quot;D:\\xampp\\tmp&quot;xdebug.remote_enable = Onxdebug.remote_handler = dbgpxdebug.remote_port = 9000//服务器监听端口xdebug.idekey = PHPSTORM//调试器的关键字，在phpstrom配置时要用到 3、验证Xdebug是否安装成功查看phpinfo，查看xdebug的参数设置。 4、phpstorm中Debug配置File&gt;Settings&gt;Languages &amp; Frameworks&gt;PHP首先要配置PHP解释器的路径（曾经因为没配解释器路径Xdebug一直运行不成功） File&gt;Settings&gt;Languages &amp; Frameworks&gt;PHP&gt;Debug 5、phpstorm中服务器配置 6、设置debug添加PHP Web Application 7、到这里，目前phpStorm+xdebug的配置基本完成了，现在来开始调试了打开电话监听按钮，打好一个断点，选择Application，点击甲壳虫按钮。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"js动态添加DOM，绑定事件会重复执行","date":"2017-11-09T07:53:23.963Z","path":"2017/11/09/on_event/","text":"使用动态 js 添加DOM，同时对加入的内容绑定点击事件的时候。该事件会重复执行比如：12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;checkbox1&quot;&gt; &lt;h1&gt;这是个标题&lt;/h1&gt; &lt;/div&gt;&lt;div class=&quot;change&quot; style=&quot;cursor: pointer;color: red;&quot;&gt;点击添加一个标题&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/components.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.change&quot;).click( function () &#123; $(&quot;.checkbox1&quot;).append(&apos;&lt;div class=&quot;check-all&quot;&gt;&lt;span&gt;&lt;h2&gt;这是另外一个标题&lt;/h2&gt;&lt;/span&gt;&lt;/div&gt;&apos;); //$(&quot;.check-all span&quot;).off(&quot;click&quot;); $(&quot;.check-all span&quot;).click(function () &#123; console.log(&quot;a&quot;); &#125;) /* $(&quot;.check-all span&quot;).unbind(&quot;click&quot;).click(function()&#123; console.log(&quot;ss&quot;); &#125;);*/ /* $(&quot;.checkbox1&quot;).on(&quot;click&quot;, &quot;.check-all span&quot;, function () &#123; console.log(&quot;ss&quot;); &#125;);*/ &#125;); &lt;/script&gt;&lt;/body&gt; 你添加两次标题的时候，你会发现，console 台输出了2次 a。解决办法如下：1、在 绑定事件之前，对该事件解绑，1234$(&quot;.check-all span&quot;).off(&quot;click&quot;); $(&quot;.check-all span&quot;).click(function () &#123; console.log(&quot;aa&quot;); &#125;) 2、unbind(‘click’)上一次的click事件123$(&quot;.check-all span&quot;).unbind(&quot;click&quot;).click(function()&#123; console.log(&quot;ss&quot;); &#125;); 建议：不要通过on的方式绑定事件，这种方式会将原来的方法添加到新方法中，就会出现执行多次。123$(&quot;.checkbox1&quot;).on(&quot;click&quot;, &quot;.check-all span&quot;, function () &#123; console.log(&quot;ss&quot;); &#125;);","tags":[]},{"title":"Angular 数据绑定与常用指令","date":"2017-11-09T07:53:23.957Z","path":"2017/11/09/ng_zhiling/","text":"数据绑定Angular 数据绑定使用了大量的括号。可以根据数据流动方式分为三种数据绑定，分别是：1、单向：从数据到视图方向（属性绑定，模板插值）。1234// 模板插值用 &#123;&#123;&#125;&#125;&lt;p&gt;&#123;&#123;studentId&#125;&#125;&lt;/p&gt; //属性绑定用 []&lt;div [title]=&quot;name&quot;&gt;&lt;/div&gt; 2、单向：从视图到数据方向（事件绑定)。12// 事件绑定用()&lt;div (click)=&quot;getId()&quot;&gt;&lt;/div&gt;&gt; 3、双向绑定。12 // 双向绑定用[()]&lt;div [(title)]=&quot;name&quot;&gt;&lt;/div&gt; 常用指令1、NgClass通过NgClass可以同时添加或移出多个类，NgClass的第一个参数为css类名称，第二个参数为布尔类型的数据值value。当value为true时则添加对应的类名到模板元素中，反之则移除。1234//基本用法&lt;div [ngClass]=&quot;&#123;&apos;text-success&apos;:true&#125;&quot;&gt;&lt;/&lt;div&gt; //判断&lt;div [ngClass]=&quot;&#123;&apos;text-success&apos;:username == &apos;anne&apos;&#125;&quot;&gt;&lt;/div&gt; 2、NgStyle可以给模板元素设置单一元素。1234//基本用法&lt;div [ngStyle]=&quot;&#123;&apos;background-color&apos;:&apos;green&apos;&#125;&quot;&gt;&lt;/&lt;div&gt; //判断添加&lt;div [ngStyle]=&quot;&#123;&apos;background-color&apos;:username === &apos;zxc&apos; ? &apos;green&apos; : &apos;red&apos; &#125;&quot;&gt;&lt;/&lt;div&gt; 3、NgIfNgIf指令绑定一个布尔类型的表达式，当表达式返回true时，可以在DOM树节点上添加一个元素及其子元素，反之将其移除。1&lt;div *ngIf=&quot;count===0&quot;&gt;&lt;/&lt;div&gt; 4、NgSwitchNgSwitch指令需要结合NgSwitchCase和NgSwitchDefault指令来使用。123456&lt;div [ngSwitch]=&quot;state&quot;&gt; &lt;template *ngSwitchCase=&quot;&apos;state1&apos;&quot;&gt;State1&lt;/template&gt; &lt;template *ngSwitchCase=&quot;&apos;state2&apos;&quot;&gt;State2&lt;/template&gt; &lt;template *ngSwitchCase=&quot;&apos;state3&apos;&quot;&gt;State3&lt;/template&gt; &lt;template *ngSwitchDefault&gt;default&lt;/template&gt;&lt;/div&gt; 5、NgFor123&lt;ul&gt; &lt;li *ngFor=&quot;let listItem of lists&quot;&gt;&#123;&#123;listItem.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Angular 启动过程","date":"2017-11-09T07:53:23.952Z","path":"2017/11/09/ng_start/","text":"在前面有一片博客中写到 用Angular Cli 构建 Angular 项目，那接着这里来了解下Angular项目的启动过程。 项目启动主要通过../src下的两个文件，main.ts 和index.html。main.ts加载脚本，负责引导整个Angular应用的起点。12345678910111213141516// 导入enableProdMode用来关闭angular开发者模式import &#123; enableProdMode &#125; from &apos;@angular/core&apos;;// 负责从angular浏览器模块中导入platformBrowserDynamic这个方法，// 这个方法告诉angular使用哪个模块来启动整个应用import &#123; platformBrowserDynamic &#125; from &apos;@angular/platform-browser-dynamic&apos;;// 整个应用的主模块import &#123; AppModule &#125; from &apos;./app/app.module&apos;;// angular多环境支持import &#123; environment &#125; from &apos;./environments/environment&apos;;if (environment.production) &#123; // 如果是工厂模式，就启动enableProdMode来关闭开发者模式 enableProdMode();&#125;// 调用bootstrapModule方法来传入AppModule作为启动模块来启动应用。platformBrowserDynamic().bootstrapModule(AppModule); index.html加载页面，寻找启动模块（AppModule）指定的主组件对应的选择器。12345678910111213141516&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Mytest&lt;/title&gt; &lt;base href=&quot;/&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt;&lt;/head&gt;&lt;body&gt;//appcomponent启动后加载完所有依赖会寻找到index里面的app-root，会根据app-root找到叫app-root的css选择器，去加载这个选择器所对应的html内容，在app-root的位置替代aoo-root显示 &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Angular 路由以及路由分离","date":"2017-11-09T07:53:23.944Z","path":"2017/11/09/ng_router/","text":"我们要使用 Angular 路由器进行导航，改变页面内容。下面我们来看Angular路由的使用方法： 1、base href打开index.html，确保它的head区顶部有一个 base href=”…”元素12&lt;head&gt; &lt;base href=&quot;/&quot;&gt; 2、配置路由在src/app/app.module.ts中引入RouterModule,再定义和配置路由数组。这里以 heroes 定义路由为例： 12345678910import &#123; RouterModule &#125; from &apos;@angular/router&apos;; imports: [ RouterModule.forRoot([ &#123; path: &apos;heroes&apos;, component: HeroesComponent &#125; ]) ], 路由定义包括以下部分：Path: 路由器会用它来匹配浏览器地址栏中的地址，如heroes。Component: 导航到此路由时，路由器需要创建的组件（HeroesComponent）。 3、路由插座在浏览器输入http://localhost:4200/heroes，路由是还没有效果的，需要一个路由出口。下面我们在src\\app\\app.component.html的末尾加上：1&lt;router-outlet&gt;&lt;/router-outlet&gt; 重新查看http://localhost:4200/heroes，你会发现页面上显示出了 HeroesComponent组件的内容。 4、通配路由如果输入一个无效的路由地址，页面是不会有效果的。这个时候我们可以新建一个404组件，所有无效的路由地址都显示该组件。配置如下：1234&#123; path: &apos;**&apos;, component: Code404Component &#125;, 注意，通配路由要放在路由配置项的最后面。 5、路由分离目前路由已经可以用起来了，但是还有个小问题，就是直接在app.modules.ts中定义路径并不是很好的方式，因为随着路径定义的复杂，这部分最好还是用单独的文件来定义。现在，新建文件src\\app\\app-routing.module.ts，将上面在app.modules.ts中定义的路由删除并在app.routes.ts中重新定义：src\\app\\app-routing.module.ts文件内容如下：1234567891011121314151617181920212223import &#123;NgModule&#125; from &apos;@angular/core&apos;;import &#123;RouterModule, Routes&#125; from &apos;@angular/router&apos;;import &#123; HeroesComponent &#125; from &apos;./heroes.component&apos;;import &#123; Code404Component &#125; from &apos;./code404/code404.component&apos;;export const routes: Routes = [ &#123; &#123; path: &apos;heroes&apos;, component: HeroesComponent &#125;, &#123; path: &apos;**&apos;, component: Code404Component &#125;,];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule], providers: []&#125;)export class AppRoutingModule &#123;&#125; 接下来，在app.modules.ts中引入AppRoutingModule.现在，app.modules.ts的内容如下：123456789101112131415161718192021222324252627282930313233import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; FormsModule &#125; from &apos;@angular/forms&apos;;import &#123; HttpModule &#125; from &apos;@angular/http&apos;;import &#123; CommonModule &#125; from &apos;@angular/common&apos;;import &#123;AppRoutingModule&#125; from &apos;./app-routing.module&apos;; // 引用路由主文件import &#123; AppComponent &#125; from &apos;./app.component&apos;;import &#123; HeroesComponent &#125; from &apos;./heroes.component&apos;;import &#123; Code404Component &#125; from &apos;./code404/code404.component&apos;;@NgModule(&#123; declarations: [ // 模块中有什么东西，只能声明组件，指令，管道 AppComponent, HeroesComponent, Code404Component ], imports: [ // app模块依赖的东西 BrowserModule, FormsModule, HttpModule, CommonModule, AppRoutingModule ], providers: [], bootstrap: [ // 模块的主组件， AppComponent ],&#125;)export class AppModule &#123; &#125; 这样两个文件分开是不是更加的清晰明了，方便后面的维护。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Angular 引入第三方库","date":"2017-11-09T07:53:23.940Z","path":"2017/11/09/ng_chajian/","text":"如果我们在开发Angular应用的时候想使用第三方的库，比如jQuery或bootstrap等，该如何去引入并使用呢？主要通过三步： 1、下载12$ npm install jquery –-save-dev$ npm install bootstrap –-save-dev 打开，package.json 文件，你会发现列出的依赖中加上了 jquery，bootstrap。 2、引入打开.angular-cli.json这个文件，可以看到 app 中有个styles数组和scripts数组。“styles”里面存放要引入的css“scripts”里面存放要引入的js 要引入第三方的包，首先要知道引入文件的路径，下载的这些包，会存放在node_modules目录中。找到路径，写入scripts中。12345678&quot;styles&quot;: [ &quot;styles.css&quot;, &quot;../node_modules/bootstrap/dist/css/bootstrap.css&quot; ], &quot;scripts&quot;: [ &quot;../node_modules/jquery/dist/jquery.js&quot;, &quot;../node_modules/bootstrap/dist/js/bootstrap.js&quot; ], 3、安装类型描述文件因为Angular是使用TypeScript语言开发的，而jquery本质是JavaScript，TypeScript是不能直接使用的。我们需要先安装类型描述文件，让TypeScript认识jquery。12$ npm install @types/jquery -–save-dev$ npm install @types/bootstrap -–save-dev 4、小结 最后，讲一下，我在安装过程中遇到的巨坑。 安装完 jquery类型描述文件之后 ，运行一直报错，江山一片红，出现如下提示：12345678910111213141516171819ERROR in C:/Users/yanling.zhong/data-center/node_modules/@types/bootstrap/index.d.ts (114,32): Generic type &apos;JQuery&lt;TElement, HTMLElement&gt;&apos; requires 2 type argument(s).ERROR in C:/Users/yanling.zhong/data-center/node_modules/@types/bootstrap/index.d.ts (116,42): Generic type &apos;JQuery&lt;TElement, HTMLElement&gt;&apos; requires 2 type argument(s).ERROR in C:/Users/yanling.zhong/data-center/node_modules/@types/bootstrap/index.d.ts (117,32): Generic type &apos;JQuery&lt;TElement, HTMLElement&gt;&apos; requires 2 type argument(s).ERROR in C:/Users/yanling.zhong/data-center/node_modules/@types/bootstrap/index.d.ts (119,44): Generic type &apos;JQuery&lt;TElement, HTMLElement&gt;&apos; requires 2 type argument(s).ERROR in C:/Users/yanling.zhong/data-center/node_modules/@types/bootstrap/index.d.ts (121,36): Generic type &apos;JQuery&lt;TElement, HTMLElement&gt;&apos; requires 2 type argument(s). 找了很久发现是 @types/jquery 的版本问题，默认安装的是3.2.6版本。现在安装2.0.39版本1$ npm install @types/jquery@2.0.39 -–save-dev 再运行，没有问题了。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Angular2 概要","date":"2017-11-09T07:53:23.936Z","path":"2017/11/09/ng_about/","text":"一、Angular2.0的诞生AngularJs1.X的困境：1、性能问题，采用脏检查实现数据更新，当页面的数据越来越多，脏检查的效率就会越来越低。2、落后于当前的web发展理念。3、对手机端支持不够友好，Angular1.x没有针对移动 应用特别优化，并且缺少一些关键的特性，需要依赖IONIC移动app开发框架。Angular2.x的优势:1、移出了controller+$scope设计，改为组件式的开发。2、性能上的优化，渲染更快，变化检测效率更高。3、仿照web后端的结构模式来编写前端，支持模块，类等特性。4、支持原生移动设备开发。5、更加贴合未来的标注，引入了TypeScript。 注意：现在基本管Angular1.x的版本统称AngularJs，Angular2.x统称Angular。 二、Angular2.0 的核心模块。一个完整的Angular应用主要由六个重要部分构成，分别是：组件、模板、指令、服务、依赖注入和路由。这些组成部分各司其职，而又紧密协作。它们的关系如下图所示：","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Angular Cli 构建 Angular 项目","date":"2017-11-09T07:53:23.932Z","path":"2017/11/09/ng/","text":"一、环境搭建 基础工具安装 NodeJS 5.0以上版本,NPM 3.0以上版本；Typescript。目前我用的是（node.js 6.10.3, npm 3.10.10） 安装Angular Cli 有两种方式安装：强烈建议使用npm安装@angular/cli，不推荐使用淘宝镜像cnpm来安装。 第一种安装方式，通过淘宝镜像。 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org //先安装cpm$ cnpm install -g @angular/cli //用cnpm安装 Angular Cli 第二种安装方式 1$ npm install -g @angular/cli@latest 注意事项 angular cli 安装失败，或是之前安装过，现在需要升级，一定要先卸载再重新安装。12$ npm uninstall -g @angular/cli$ npm cache clean 找到 C:\\Users\\Administrator\\AppData\\Roaming\\npm ，把ng和ng.cmd也删除 测试 1$ ng -v 显示版本信息，表示安装成功 二、Angular Cli常用命令12345$ ng new project-name //创建项目$ ng serve //编译，启动服务器$ ng serve --port 4201 //默认端口是4200 ，修改端口 $ ng generate component newComponent //在项目中构建新代码$ ng build //构建项目存储在 /dist 目录中。 更多指令请参考 三、创建项目 新建项目 第一种方式，这种方式比较慢，建议采用第二种。 123$ ng new project-name //创建项目$ cd project-name //进入目录$ ng serve //编译，启动服务器 第二种方式 1234$ ng new project-name --skip-install //创建项目,创建时不执行任何npm命令$ cd project-name //进入目录$ cnpm install //利用淘宝镜像安装npm$ ng serve //编译，启动服务器 打开浏览器输入 http://localhost:4200/，可以看到效果。 项目目录结构","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"MVC和MVVM","date":"2017-11-09T07:53:23.927Z","path":"2017/11/09/mvc/","text":"1、MVC 是应用最广泛的软件框架之一，一般MVC分为：Model（模型），View（视图），Controller（控制器）。 Model可直接访问业务数据，View数据的显示，Controller联系View和Model，基本联系是单向的。首先View传送指令给Controller；然后Controller完成逻辑后，要求Model改变状态最后：Model将新数据发送给ViewUser。MVC架构的缺点，视图与控制器间的过于紧密的链接。2、MVP是从经典的MVC演变而来，Controller/Presenter负责逻辑处理，Model提供数据，View显示数据。不过在MVP中，Presenter把View和Model进行了分离，主要的程序逻辑在Presenter中实现，而Presenter与具体的View没有直接关联，而是通过定义好的接口进行交互，使得在更变View的时候可以保持Presenter不变。3、相比于前面两种模式，MVVM只是把MVC的Controller和MVP的Presenter改成了ViewModel,基本和Mvp一致，唯一区别就是，采用双向绑定，View的变化会自动更新到ViewModel，ViewModel的变化也会同步到View上显示。","tags":[]},{"title":"双向绑定的优缺点","date":"2017-11-09T07:53:23.924Z","path":"2017/11/09/model_youdian/","text":"单向数据绑定：指的是我们先把模板写好，然后把模板和数据（数据可能来自后台）整合到一起形成HTML代码，然后把这段HTML代码插入到文档流里面。缺点：单向数据绑定缺点：HTML代码一旦生成完以后，就没有办法再变了，如果有新的数据来了，那就必须把之前的HTML代码去掉，再重新把新的数据和模板一起整合后插入到文档流中。优点：单向数据流 数据流动方向可以跟踪，流动单一，追查问题的时候可以跟快捷。 双向数据绑定：数据模型（Module）和视图（View）之间的双向绑定。缺点：各种数据相互依赖相互绑定，导致数据问题的源头难以被跟踪到，不利于管理数据源。优点:双向数据绑定最经常的应用场景就是表单了，这样当用户在前端页面完成输入后，不用任何操作，我们就已经拿到了用户的数据存放到数据模型中了。","tags":[]},{"title":"Markdown 语法的简要规则","date":"2017-11-09T07:53:23.919Z","path":"2017/11/09/markdown/","text":"1. 标题在文字前加 # 号 2. 列表在文字前加 - 或者 * 变为无序列表，在文字前加 1. 2. （符号和文字间有个空格）为有序列表 3. 引用在文本前加入&gt;即可 4. 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 5. 粗体与斜体两个 * 号为粗体，一个为斜体 6. 表格‘| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |’ 7. 代码框两个 ` 把中间的代码包裹起来 8. 分割线三个 * 号 详细可参考Markdown 编辑阅读器","tags":[{"name":"Marckdown","slug":"Marckdown","permalink":"http://yoursite.com/tags/Marckdown/"}]},{"title":"Linux常用命令","date":"2017-11-09T07:53:23.916Z","path":"2017/11/09/Linux/","text":"1、文件管理 ①查看文件 查看当前目录下的文件和目录： ls 查看当前目录下的文件和目录，获取更多的文件信息： ls -l(list) 查看隐藏文件：ls -a(all) 元字符 （* 和 ?） *可以匹配 0 个或多个任意字符 ? 匹配一个字符。 例如：$ls ch*.doc (显示所有以ch开头， 以 .doc结尾的文件) ②创建文件 $ vi filename 创建一个 filename 为名字的文件并打开，按下 i 进入编辑模式 ③查看文件内容 cat 命令来查看文件内容， -b 选项来显示行号 $ cat -b filename 复制文件（cp）重命名（mv）删除（rm） 在文件系统中搜索某文件 find 在文本文件中查找某个字符串 grep 2、目录 进入目录 cd 退出当前目录 cd - 获取当前所在的目录 pwd 文件权限 ：读取(r)、写入(w)和执行(x) 更改权限 ：sudo chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录名 3、vim使用 vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 命令模式下： 退出 :q 强制退出 :q! 保存并退出 :wq 显示行号 :set number 隐藏行号 :set nonumber","tags":[]},{"title":"跨域请求的几种方式","date":"2017-11-09T07:53:23.907Z","path":"2017/11/09/kuayu/","text":"一、为何需要跨同源策略是浏览器的基本安全功能，所谓同源，即协议、域名、端口相同。当浏览器执行一个脚本是，会检查脚本是否同源，才会去执 行！如果不同如何去执行呢，这时候就需要跨域！ 二、跨域的具体方式提到跨域，可能光想到有个jsonp。然而jsonp是什么，跨域还有没有其他方式就不知道了，所下面来了解下跨域的几种方式及原理： 1、jsonp(json with padding) 在前面讲到浏览器有同源策略的限制，但是 &lt;img&gt;的src，&lt;link&gt;的href，&lt;script&gt;的&lt;script&gt;所以你会发现A网站的图片地址，放到B网站同样也可以显示。 jsonp，就是&lt;script&gt;的src不符合同源策略而来的。通过&lt;script&gt;的src动态引入文件，返回服务器端数据。 2、 3、 4、","tags":[]},{"title":"Javascript 模板引擎","date":"2017-11-09T07:53:23.903Z","path":"2017/11/09/js_template/","text":"","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"js事件委托","date":"2017-11-09T07:53:23.900Z","path":"2017/11/09/js_event/","text":"事件委托 就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 比如一个ul有100个li， 这 100个 li 都有相同的点击事件，如果我们采用循环的方法对这100个liclick方法，这样我们就需要不断的和DOM节点交互，DOM访问次数越多，DOM重绘重排就越多。可是如果使用 事件委托机制去处理的话，我们只需要给 ul 加上个点击事件就可以了，DOM操作只需交互一次，大大提高性能。 那事件委托是怎么去实现的呢? 事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 如果我们只想在点击li的时候触发 点击事件，点击 ul的时候不会触发，这个时候我们可以使用（target）：Event对象提供了一个属性叫target，可以返回事件的目标节点，也就是目标源，target就可以表示最初触发事件的DOM元素，标准浏览器用ev.target，IE浏览器用event.srcElement,这时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写（target.nodeName.toLowerCase）再做比较 if(target.nodeName.toLowerCase() == ‘li’) 通常我们会比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"js运算出现多位小数问题","date":"2017-11-09T07:53:23.893Z","path":"2017/11/09/js_division/","text":"不知道你们有没有踩过，js运算时出现多位小数的坑，比如 22.77+10，结果竟然是32.769999999996。目前我的解决方案是这样的：首先将小数变成整数，然后再除于相应的倍数。比如上面的计算可以写成（（22.77×100）+（10×100））/100 12345678910111213141516function getNumber()&#123; var a = 22.77; var b = 10; var aa = Math.pow(10,data_rate(a));//a放大的倍数 var bb = Math.pow(10,data_rate(b));//b放大的倍数 var cc = aa*bb;//总共放大的倍数 alert(((a*cc)+(b*cc))/cc)&#125;function data_rate(str)&#123;//这里计算放大多少倍 str = str.toString(); if(str.indexOf(&quot;.&quot;) == -1)&#123; return 1; &#125;else&#123; return parseInt(str.length-str.indexOf(&quot;.&quot;)-1); &#125; &#125;","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"encodeURl()加号变空格问题","date":"2017-11-09T07:53:23.888Z","path":"2017/11/09/js_decode/","text":"使用 encodeURIComponent() ，嘿嘿。。。。","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Javascript闭包","date":"2017-11-09T07:53:23.878Z","path":"2017/11/09/js_closure/","text":"一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n=999;function f1()&#123;alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 1234unction f1()&#123;var n=999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 12345function f1()&#123;n=999;&#125;f1();alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1()&#123;var n=999;function f2()&#123;alert(n); // 999&#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chainscope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789function f1()&#123;var n=999;function f2()&#123;alert(n); &#125;return f2;&#125;var result=f1();result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。123456789101112function f1()&#123;var n=999;nAdd=function()&#123;n+=1&#125;function f2()&#123;alert(n);&#125;return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行， 首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 六、思考题如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。代码片段一:12345678910var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;;&#125;&#125;;alert(object.getNameFunc()()); 代码片段二: 1234567891011var name = &quot;The Window&quot;;var object = &#123;name : &quot;My Object&quot;,getNameFunc : function()&#123;var that = this;return function()&#123;return that.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Hexo+Github 搭建博客","date":"2017-11-09T07:53:23.873Z","path":"2017/11/09/hexo/","text":"1. 安装node安装Node（必须）作用：用来生成静态页面的到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须）作用：把本地的hexo内容提交到github上去。 2. 安装hexo创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。（Windows cmd 执行如下命令）安装Hexo：npm install -g hexo初始化hexo：hexo init好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。可以本地启动，进行文章预览：hexo server 或者（hexo s）浏览器输入http://localhost:4000 ,现在你就可以看到你的页面啦 文件夹结构：scaffolds 工具模板scripts hexo的功能jssource 博客资源文件夹source/_drafts 草稿文件夹source/_posts 文章文件夹themes 存放皮肤的文件夹themes/landscape 默认皮肤文件夹_config.yml 全局配置文件db.json json格式的静态常量数据库_posts目录：Hexo存放博客文章的文件夹themes目录：存放皮肤的文件夹，默认使用官方的主题 你也可以从hexo主题页面下载你喜欢的主题 3. 配置githubgithub 是用来做博客的远程创库、域名、服务器之类的 新建 Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】 找到blog根目录下的 _config.yml 文件 把 deploy 改成deploy: type: git repo: https://github.com/ZYLyanzi/ZYLyanzi.github.io.git（你新建的github的仓库地址） branch: master 执行命令npm install hexo-deployer-git –save （windows 用 git brash）按照github新建仓库的指引，执行命令：git initgit add README.mdgit commit -m “first commit”git remote add origin https://github.com/ZYLyanzi/yanzi.github.io.gitgit push -u origin master push 成功后执行命令：hexo cleanhexo generatehexo deploy 然后再浏览器中输入https://zylyanzi.github.io/就行了，我的github的账户叫zylyanzi,把这个改成你github的账户名就行了 一些常用的命令：hexo new”postName” #新建文章hexo new page”pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 4. hexo主题hexo 有大量的主题列表我自己使用的是yilia 5.关于 Yilia 主题","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"构建工具gulp的使用","date":"2017-11-09T07:53:23.869Z","path":"2017/11/09/gulp/","text":"gulp的安装 1、 安装node.js 如果是新建项目，执行 npm init 创建package.json文件 2、全局安装gulp $ npm install –global gulp 3、项目本地安装gulp $ npm install –save-dev gulp( –save 可以让gulp插件显示在 package.json中) gulp的使用1、新建 gulpfile.js 文件在项目根目录下创建一个名为 gulpfile.js 的文件。 此时我们的目录结构是这样的：├── gulpfile.js├── node_modules│ └── gulp└── package.json 2、API介绍gulp有四个常用的API:1234gulp.src()gulp.task()gulp.dest()gulp.watch() 更多API可以参考 gulp API 文档 2.1 gulp.src() gulp.src(globs[, options])globs：参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。options：为可选参数。 2.2 gulp.task() 用来定义任务。gulp.task(name[, deps], fn)name：为任务名deps：是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数fn：为任务函数，我们把任务要执行的代码都写在里面。 2.3 gulp.dest() 用来写文件。gulp.dest(path[, options])path：为写入文件的路径options：为一个可选的参数对象 2.4 gulp.watch() 用来监听文件变化。gulp.watch(glob[, opts, cb])glob：为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。opts：为一个可选的配置对象，通常不需要用到tasks：为文件变化后要执行的任务，为一个数组 3、插件 插件的安装 $npm –save-dev install 插件名 更多插件可以参考官方文档","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"git撤销操作","date":"2017-11-09T07:53:23.866Z","path":"2017/11/09/git_checkout/","text":"取消对文件的修改 git checkout --path/to/file.c 取消已经暂存的文件 暂存文件说明：修改了文件，执行git add命令后,就变成暂存的文件。git reset HEAD --path/to/file.c 撤销本地提交（commit） 查看提交历史git log 查看各个提交历史的统计git log --stat 查看最近N次提交的具体差异git log -p -N 撤销上一次提交（git commit了，但没有git push）git reset --hard 版本序列号","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"一张图读懂 git远程操作","date":"2017-11-09T07:53:23.861Z","path":"2017/11/09/git/","text":"Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 命令详解： $ git clone &lt;版本库的网址&gt;，，，，支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议 $ git remote 列出远程主机名（-v，可查看远程主机网址） $ git fetch &lt;远程主机名&gt; &lt;分支名&gt;​ 将远程主机的更新，全部取回到本地 $ git pull 取回远程主机某个分支的更新，再与本地的指定分支合并（相当于先 git fetch 再 git merge） $ git push 将本地分支更新，推送到远程主机 $ git add 暂存。git 有个概念叫暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 git commit 提交。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Flex 布局","date":"2017-11-09T07:53:23.857Z","path":"2017/11/09/flexbox/","text":"布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。 一、布局模型采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置叫做main start，结束位置叫main end；交叉轴的开始位置叫做cross start,结束位置叫做cross end。项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 二、伸缩容器属性伸缩容器支持的属性有： display flex-direction flex-wrap flex-flow justify-content align-items align-content 1、display 该属性用来指定元素是否为伸缩容器：display:flex | inline-flex flex:产生块级伸缩容器。 inline-flex:行内级伸缩容器。 注意：当display：flex时，css的colums在伸缩容器上没有效果，float，clear，vertical-align在伸缩项目上没有效果。 2、flex-direction 该属性用来指定主轴方向：flex-direction: row | row-reverse | column | column-reverse row（默认值）: 主轴为水平方向，起点在左端，伸缩项目从左向右排列。 row-reverse ：主轴为水平方向，起点在右端，伸缩项目从右到左排列。 column: 主轴为水平方向，起点在左端，伸缩项目从上到下排列。 column-reverse ：主轴为水平方向，起点在右端，伸缩项目从上到下排列 3、flex-wrap 该属性主要用来指定伸缩容器主轴线方向空间不足的情况下，是否换行已经如何换行：flex-wrap: nowrap | wrap | wrap-reverse nowrap ：不换行。 wrap: 允许换行，从上到下。 wrap-reverse ：允许换行，从下到上。 4、flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的缩写版本，同时定义了伸缩容器的主轴和侧轴，默认值为row nowrap。 flex-flow: flex-direction flex-wrap; 5、justify-content 改属性定义了项目沿主轴的对齐方式：justify-content: flex-start | flex-end | center | space-between | space-around 具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 6、align-items 该属性定义了项目在交叉轴的对齐方式：align-items: flex-start | flex-end | center | baseline | stretch flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 7、align-content 该属性用来调整项目出现换行后在交叉轴上的对齐方式：align-content: flex-start | flex-end | center | space-between | space-around | stretch flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 三、伸缩项目属性伸缩容器支持的属性有： order flex-grow flex-shrink flex-basis flex align-self 1、order 这个属性用来定义项目的排序顺序。数值越小，排列越靠前，默认值为0：order: integer 2、flex-grow 该属性用来定义伸缩项目的放大比例，默认值为0，即如果存在剩余空间，也不放大。如果所有的伸缩项目的flex-grow设置为1，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果将其中一个伸缩项目设置为2，那么这个项目所占的剩余空间是其他项目所占的剩余空间的两倍：flex-grow：number 3、flex-shrink 该属性用来定义伸缩项目的收缩能力，默认值为1：flex-shrink：number 比如：将某个项目设为 flex-shrink：3，则该元素在空间不足的情况下，缩小为其他元素大小的1/3. 4、flex-basis 该属性用来定义伸缩项目的基准值，剩余的空间按比率进行伸缩：flex-basis：length | auto 5、flex 该属性是,flex-grow,flex-shrink,flex-basis这三个属性的缩写：flex：none | flex-grow lex-shrink flex-basis 6、align-self 该属性用来设置单独项目在交叉轴上的对齐方式，会覆写默认的对齐方式：align-self：auto | flex-start | flex-end | center | baseline | stretch auto：伸缩项目按照自身设置的宽高显示，如果没有设置，则按stretch来计算其值。 flex-start：伸缩项目向交叉轴的起始位置靠齐。 flex-end：伸缩项目向交叉轴的结束位置靠齐。 center：伸缩项目向交叉轴的中心位置靠齐。 baseline：按基线对齐。 stretch（默认值）：在交叉轴方向沾满伸缩容器。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"ES6 模板字符串","date":"2017-11-09T07:53:23.849Z","path":"2017/11/09/es6_template_string/","text":"一、认识反引号在传统的JavaScript输出模板通常是这样写的。123456$(&apos;#result&apos;).append( &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; + &apos;items in your basket, &apos; + &apos;&lt;em&gt;&apos; + basket.onSale + &apos;&lt;/em&gt; are on sale!&apos;); 以上写法繁琐不方便，ES6引入了模板字符串来解决这个问题。12345$(&apos;#result&apos;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串是增强版的字符串。用反引号（`）来标识。 二、用法它可以当做普通字符串使用，也可以用来定义多行字符串，12345678910// 普通字符串`In JavaScript &apos;\\n&apos; is a line-feed.`// 多行字符串`In JavaScript this isnot legal.`// 字符串中嵌入变量var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` // Hello Bob, how are you today? 注意:1、在模板字符串两端都使用了反引号，而如果在模板字符串中间需要使用反引号，则需要在其前面使用反斜杠转义。1var greeting = `\\`Yo\\` World!`; // `Yo` World! 3、在模板字符串中嵌入变量，需要将变量名写在 ${}中。{} 内可以放入任意的JavaScript·表达式，可以进行运算，已经引用对象属性，模板字符串中还能调用函数。123456789101112131415161718var x = 1, y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`;// &quot;1 + 2 = 3&quot;`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`;// &quot;1 + 4 = 5&quot;var obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// &quot;3&quot;//调用函数function fn() &#123; return &apos;Hello&apos;;&#125;`$&#123;fn()&#125; World`;// &quot;Hello World&quot; 4、如果使用模板字符串标识多行字符串，所用的空格缩进都会被保留在输出中。12345$(&quot;#warning&quot;).html(` &lt;h1&gt;Watch out!&lt;/h1&gt; &lt;p&gt;Unauthorized hockeying can result in penalties of up to $&#123;maxPenalty&#125; minutes.&lt;/p&gt; `); 5、如果{}中的值不是字符串，将按照一定规则转成字符串。比如大括号中的是个对象，将默认调用对象的toString方法。 三、标签模板标签模板其实不是模板，而是函数调用的一种特殊形式。“标签” 指的就是函数，紧跟在后面的模板字符从就是它的参数。123var a = 5;var b = 10;tag `hello $&#123;a+b&#125; world $&#123;a*b&#125;`; 上面代码中，模板字符串前面的标识“tag”，它就是个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。1234//等同于function tag（value1, value2）&#123; ...&#125; 四、String.raw() 方法String.raw方法用来充当模板字符串的处理函数，返回一个除表达式和变量会被替换，其它都保持原样的字符串。String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的let和const","date":"2017-11-09T07:53:23.842Z","path":"2017/11/09/es6_let/","text":"一、块级作用域所谓“块”，就是大括号“｛｝”中间的语句。ES5只有全局作用域和函数作用域，没有块级作用域，这带来了很多不合理的场景。 1、变量提升，导致内层变量覆盖外层变量。123456var tmp = 20;function f()&#123; console.log(tmp); //变量提升，仅提升变量名，为提升变量值 var tmp = &quot;hello&quot;;&#125;f();// undefined var 是函数作用域。在整个函数中甚至是声明语句之前都是可用的。声明被提升。所以你能在声明之前使用一个变量。 2、用来计数的循环变量泄露为全局变量。1234567var a = [];for(var i = 0; i &lt; 10; i++)&#123; a[i] = function()&#123; console.log(i);&#125;;&#125;a[6](); // 10 上面代码中i是var声明的，在全局范围内有效。每次循环，新的i值都会覆盖旧值，最后输出10。上面代码定义的 i 只用来控制循环，但是循环结束后并没有消失，而是泄露成了全局变量。 所以ES6就有了let和const命令为JavaScript增加块级作用域。1234567var a = [];for(let i = 0; i &lt; 10; i++)&#123; a[i] = function()&#123; console.log(i);&#125;;&#125;a[6](); // 6 上面代码中i是let声明的，当前的i只在本轮循环有效。所以每一次的循环i都是个新的变量，最后输出6。所以for循环计数器很适合用let命令。 二、let和const命令 let命令的使用： 1、let不存在变量提升，变量一定要先声明后使用，否则会报错。2、let命令声明变量之前，该变量都是不可用的，语法称为“暂时性死区”—即代码块开始，到变量使用之前的区间。3、使用let命令声明的变量“绑定”在这个块级区域内，不再受外部影响，所以外层作用域无法读取内层作用域的变量。4、let不允许在相同作用域内重复声明一个变量。 块级作用域的出现，使得立即执行匿名函数（IIFE）不再必要了。 const命令的使用 1、const用来声明常量，一旦声明，其值就不能改变。2、对于const而言，只声明，不赋值就会报错。3、const也不可以重复声明变量。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6简介及转码","date":"2017-11-09T07:53:23.837Z","path":"2017/11/09/es6/","text":"一、ES6是什么ECMAScript6（简称ES6）是JavaScript语言的下一代标准，于2015年6月发布。所以ES2015，也就是ES6。ECMAScript是JavaScript的规格，JavaScript是ECMAScript的一种实现。 二、浏览器对ES6的支持情况。详细情况可查阅 http://kangax.github.io/compat-table/es6/。可以看出基本上没有浏览器完全支持ES6，所以一般不要直接用的好，但是我们可以用 转码器 把ES6转换为被浏览器接受的ES5。 三、ES6转码Babel是一个对ES6支持程度较高，使用范围较广的转码器。Babel使用方法总结： 1、在命令行中使用 12345678910111213141516171819$ npm install --global babel-cli# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s 2、浏览器环境 这个方法的缺点是实时转码需要时间，性能上不及预先转换的方案，因此生产环境中不推荐使用，仅供学习研究使用。首先我们需要下载browser.js，注意，这是 Babel 5 的版本，Babel 6 开始不再直接提供该文件，需要自行构建。除了从上面的链接下载，你也可以用 npm 下载：npm install babel-core@5下载后在node_modules/babel-core子目录中就能找到browser.js文件。使用方法如下：12&lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot; src=&quot;your_own_es6_file.js&quot;&gt;&lt;/script&gt; 有两点需要注意browser.js 文件必须放在你自己的 js 文件之前你自己的文件的类型要写成type=”text/babel” 3、在线转换 Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"vue基础笔记整理","date":"2017-11-09T07:53:23.829Z","path":"2017/11/09/about_vue/","text":"一、基本概念vue核心思想：数据驱动，组件化。vue特点：轻量，数据绑定，指令，模块化。传统视图驱动：js操作dom数据驱动：当数据发生变化时，用户界面发生相应的变化，不需要手动修改dom 1、数据绑定方式：123456789101112&lt;!-- 插值 --&gt;&#123;&#123; message &#125;&#125;&#123;&#123;&#123; htmlSegment &#125;&#125;&#125;&lt;img src=&quot;&#123;&#123; photoURL &#125;&#125;&quot; /&gt;&lt;!-- 表达式 --&gt;&#123;&#123;true ? 1 : 0&#125;&#125;&lt;!-- 指令 --&gt;&lt;div v-if=&quot;upgradable&quot;&gt;升级指南：...&lt;/div&gt;&lt;span v-text=&quot;anotherMessage&quot;&gt;&lt;/span&gt;&lt;div v-html=&quot;anotherHTMLSegment&quot;&gt;&lt;/div&gt;&lt;li v-bind:class=&quot;&#123;&apos;current&apos;: thisIsTheCurrentItem&#125;&quot;&gt;Item&lt;/li&gt;&lt;a v-bind:href.literal=&quot;javascript:void(0)&quot; v-on:click.stop=&quot;doSomething&quot;&gt;Click Me&lt;/a&gt; 2、计算属性：计算属性就是当其依赖属性的值发生变化时，这个属性值会自动更新，与之相关的dom部分也会自动更新。Vue.js 提供了一个 $watch 方法用于观察 Vue 实例上的数据变动，这与 AngularJS 的做法类似。不过，通常更好的办法是使用计算属性而不是一个命令式的 $watch 回调。模板：12345678910&lt;div id=&quot;app&quot;&gt; &lt;div&gt; 长：&#123;&#123; a &#125;&#125;m、宽：&#123;&#123; b &#125;&#125;m &lt;/div&gt; &lt;input type=&quot;range&quot; v-model=&quot;a&quot;&gt; &lt;input type=&quot;range&quot; v-model=&quot;b&quot;&gt; &lt;div&gt; 长方形面积：&#123;&#123; s &#125;&#125;m&lt;sup&gt;2&lt;/sup&gt; &lt;/div&gt;&lt;/div&gt; Vue 实例：12345678910111213141516var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; a: 6, b: 5, s: 30 &#125;&#125;)vm.$watch(&apos;a&apos;, function (val) &#123; this.s = val * this.b&#125;)vm.$watch(&apos;b&apos;, function (val) &#123; this.s = this.a * val&#125;) 如果使用计算属性，我们只需要编写一次计算逻辑，Vue.js 会自动建立该计算属性与 Vue 实例数据 a、b 的依赖关系并追踪变化：123456789101112var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; a: 6, b: 5 &#125;, computed: &#123; s: function () &#123; return this.a * this.b &#125; &#125;&#125;) 我们可以设置计算属性的getter和setter。计算属性getter不执行场景：当计算属性的节点被移除并且模板其他地方没有引用该属性时，那么对应的计算属性getter方法不会执行。 一般情况下，使用计算属性比 $watch 实现简洁、维护方便，对于需要观察 Vue 实例数据变动的需求，如无特殊情况均应优先使用计算属性。 根据 Vue.js 的 $watch API 文档，当调用 Vue 实例的 $watch 方法创建 $watch 时，返回一个 unwatch 函数，用于取消观察，因此在需要取消观察的场合，使用 $watch 为佳。 3、条件渲染的注意事项：12345多于一个元素的 v-if 需要使用 &lt;template&gt;v-show 不支持 &lt;template&gt;v-else 必须紧跟在 v-if/v-show 指令后面组件条件下不能使用 &lt;v-else&gt;将v-show用在组件上时，因为指令的优先级v-else会出现问题，所以我们可以使用另一个v-show来替换v-else 4、数据变化检测：包装了观察数组变异的方法：push(),pop(),shift(),unshift(),splice(),sort(),reverse()。观测变化的两个方法：$set,$remove.track-by特殊属性。 5、v-bind绑定类与样式：使用数组语法时，绑定表达式可以直接是 Vue 实例的 Data 属性中的一个数组，根据在列表渲染中所学到的关于数据变化检测的原理及对数组方法的包装和扩充知识，可以知道，Vue.js 支持使用 push 和 $remove 方法实现元素数量的变化，从而实现了 addClass 和 removeClass 的功能。 6、表单控件绑定：使用v-model指令同步用户输入的数据到vue实例data属性中。v-model修饰指令：lazy，debounce，number 7、事件绑定与处理：使用 v-on 指令来监听DOM事件，当click事件与某个方法绑定的时候，定义的方法放在methods属性下。methods中定义的方法内的this始终指向创建的Vue实例；与事件绑定的方法支持参数event即原生DOM事件的传入。 v-on还可以使用内联语句处理，但是限制为一个语句，这个时候如果要访问原生的DOM事件，要用$event. 事件修饰符：.prevent .stop .capture .self事件处理器中，event.preventDefault()用来阻止事件的默认行为，event.stopPropagation()用来阻止事件冒泡。.prevent相当于event.preventDefault()，.stop相当于event.stopPropagation()，.capture捕获方式侦听事件，事件以与冒泡方式相反的方式在 DOM 树上传递，.self限制只接受自身触发的事件。 按键修饰符：（可以简化键盘的keycode处理）enter，tap，delete，esc，space，up，down，left，right 8、watch的使用：watch:一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 我们对计算属性和 $watch 进行了简单的比较，对于有多个依赖需要追踪的情形，优先使用计算属性。对于由一个数据变化引发多个数据、状态变化的情况，我们推荐使用 watcher；数据变化触发组件间或前后端交互的情况，使用 watcher 也更简明。 关于 watcher 的应用场合，试举例如下：1.某元素通过 v-show 显示后延时隐藏，可以观察 v-show 所绑定的数据，当数据为真时，启动定时器延时重新设置 v-show 所绑定的数据隐藏元素；2.日历控件中，日期数值发生变化，获取年、月，计算并重绘日历面板；3.分页控件用户点击页码触发 pageIndex 数据变化，观察到 pageIndex 变化时触发向后端发起 AJAX 请求，获取该页码中的数据记录，并在获取数据记录后更新分页控件中的页码及状态；4.用户输入地址，数据变化触发向高德地图发起 AJAX 请求，获取相类似的地址列表并实现 auto-complete； 由于 watcher 通过函数回调响应数据变化，而在回调函数中还有可能触发其他数据变化引发其他 watcher 回调，因此需要避免滥用造成回调结构过于复杂，影响性能。 二、组件开发组件的核心目标是为了提高可复用性。一般我们把组件按照template，style，script的拆分方式，放到.vue文件中。 1、注册与使用:全局注册，局部注册2、数据传递：props:子组件需要用props选项来获取父组件的数据。使用v-bind将动态的props绑定到父组件的数据。默认绑定是单向的，但是可以使用绑定修饰符改变：.sync双向绑定，.once单向绑定。可以给props指定验证要求，指定type，当验证失败时，Vue.js将拒绝在子组件上设置此值。 slot:slot 混合父组件的内容与子组件的内容，slot在bind回调函数中，根据name获取将要替换插槽的元素，具名slot将匹配内容片断钟有对应的slot特性元素。不过任然可以有一个匿名的slot，作为找不到匹配元素的内容片断的回退槽，它是默认slot。如果没有默认的slot，这些找不到匹配元素的内容片断将会被抛弃。例如：有个multi-insertion 组件 , 1234567891011121314151617&lt;div&gt; &lt;slot name = &quot;one&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name = &quot;two&quot;&gt;&lt;/slot&gt;&lt;/div&gt;父组件&lt;multi-insertion&gt; &lt;p slot = &quot;one&quot;&gt;one&lt;/p&gt; &lt;p slot = &quot;two&quot;&gt;one&lt;/p&gt; &lt;p&gt;default A&lt;/p&gt;&lt;/multi-insertion&gt;结果为&lt;div&gt; &lt;p slot = &quot;one&quot;&gt;one&lt;/p&gt; &lt;p&gt;default A&lt;/p&gt; &lt;p slot = &quot;two&quot;&gt;one&lt;/p&gt;&lt;/div&gt; 动态组件：动态组件 使用同一挂载点，然后动态的在它们之间切换。将组件名绑定到Vue.js特殊的is属性上。123&lt;component :is = &quot;currentView&quot; keep-alive&gt;&lt;!--组件在vm.currentView 变化时改变--&gt; &lt;/component&gt; 如果挂载组件发生变化，旧组件会被切换出去，切换出去的组件会被卸载。在挂载点上添加 keep-alive 属性。则组件被切换出去后还会保留在内存中，避免重新渲染。","tags":[]},{"title":"双向绑定的原理","date":"2017-11-09T07:53:23.826Z","path":"2017/11/09/about_model/","text":"","tags":[]}]